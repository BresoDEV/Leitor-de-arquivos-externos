#include<iostream>
#include<stdio.h>
#include<fstream>
#include<string>
#include <vector>
#include <windows.h> 
#include <tchar.h> 
#include <chrono>
#include <ctime> 
#include <iomanip>
#include <ctime>

#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <iterator>

using std::cout; using std::cin;
using std::endl; using std::string;
using std::vector;
using std::istringstream;


using namespace std;


namespace Extern_Reader
{
	namespace LOG
	{
		std::string arquivoTXT;

		std::string HoraAtual()
		{
			struct tm current_tm;
			char chLogBuff[5000];
			char chParameters[5000];
			time_t current_time = time(NULL);
			localtime_s(&current_tm, &current_time);
			char szTimestamp[30];
			sprintf_s(szTimestamp, "[%02d:%02d:%02d] = ", current_tm.tm_hour, current_tm.tm_min, current_tm.tm_sec);
			return szTimestamp;
		}

		void Log_ERRO(string texto)
		{
			ofstream Arquivo;
			Arquivo.open(arquivoTXT, std::ios_base::app);
			std::string a = HoraAtual() + "ERRO: " + texto;
			Arquivo << a << endl;
			Arquivo.close();
		}

		void Log(string texto)
		{
			ofstream Arquivo;
			Arquivo.open(arquivoTXT, std::ios_base::app);
			std::string a = HoraAtual() + texto;
			Arquivo << a << endl;
			Arquivo.close();
		}

		void ReiniciarLog()
		{
			ofstream Arquivo;
			Arquivo.open(arquivoTXT);
			Arquivo << "";
			Arquivo.close();
		}
	};
	namespace StringManager
	{

		bool SeContemTexto(std::string string, std::string textoProcurado)
		{
			if (string.find(textoProcurado) != std::string::npos)
				return true;
			else
				return false;
		}

		std::string ReplaceChar(std::string palavra, char letraantiga, char letranova)
		{
			std::string base = palavra;
			std::string str = base;
			str.replace(str.begin(), str.end(), letraantiga, letranova);
			return str;
		}

		std::string ReplaceWord(std::string str, const std::string& from, const std::string& to) {
			size_t start_pos = 0;
			while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
				str.replace(start_pos, from.length(), to);
				start_pos += to.length();
			}
			return str;
		}

		std::string RemoveSpaces(std::string str, const std::string& from = " ", const std::string& to = "") {
			size_t start_pos = 0;
			while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
				str.replace(start_pos, from.length(), to);
				start_pos += to.length(); // Handles case where 'to' is a substring of 'from'
			}
			return str;
		}
	}
	namespace File_Manager
	{

		void DeletarArquivo(string pathFile)
		{
			remove(pathFile.c_str());
		}

		void CriarArquivo(std::string FilePathAndExtension)
		{
			std::ofstream outfile(FilePathAndExtension);
			outfile.close();
		}

		void LimparArquivo(string arquivoTXT)
		{
			ofstream Arquivo;
			Arquivo.open(arquivoTXT);
			Arquivo << "";
			Arquivo.close();
		}
	};
	namespace Simple_TXT_file
	{
		std::string TXTFilePath;

		int GetVectorSize(std::vector<string> vetor)
		{
			return vetor.size() - 1;
		}

		namespace String
		{

			std::vector<std::string> GetValues()
			{
				std::vector<std::string> TempVECTOR;
				ifstream imput(TXTFilePath);
				string textolido;
				for (string line; getline(imput, line);)
					TempVECTOR.push_back(line);
				return TempVECTOR;
			}

			std::vector<string> Get_More_Values(std::string Arquivo, char separador = ' ')
			{
				std::vector<string> TempVECTOR;
				vector<string> tokens;
				ifstream imput(Arquivo);
				for (string line; getline(imput, line);)
				{
					istringstream tokenizer{ line };
					string token;
					while (getline(tokenizer, token, separador))
					{
						tokens.push_back(token);
					}
				}
				return tokens;

				/*
				* Exemplo de 2 valores::
				for (int i = 0; i <= Extern_Reader::Simple_TXT_file::GetVectorSize(Extern_Reader::Simple_TXT_file::String::Get_More_Values("Teste.txt")); i++)
				{
					cout << "AddOption(" << Extern_Reader::Simple_TXT_file::String::Get_More_Values("Teste.txt")[i] << "," << Extern_Reader::Simple_TXT_file::String::Get_More_Values("Teste.txt")[i + 1] << ");" << endl;
					i++;
				}

				* Exemplo de 3 valores::
				for (int i = 0; i <= Extern_Reader::Simple_TXT_file::GetVectorSize(Extern_Reader::Simple_TXT_file::String::Get_More_Values("Teste.txt")); i++)
				{
					if (i <= (Extern_Reader::Simple_TXT_file::GetVectorSize(Extern_Reader::Simple_TXT_file::String::Get_More_Values("Teste.txt")) + 3))
					{
						cout << "AddOption(" << Extern_Reader::Simple_TXT_file::String::Get_More_Values("Teste.txt")[i] << ", " << Extern_Reader::Simple_TXT_file::String::Get_More_Values("Teste.txt")[i + 1] << ", " << Extern_Reader::Simple_TXT_file::String::Get_More_Values("Teste.txt")[i + 2] << ");" << endl;
						i++;
						i++;
					}
				}
				*/
			}
		}
		namespace Int
		{

			std::vector<int> GetValues()
			{
				std::vector<int> TempVECTOR;
				ifstream imput(TXTFilePath);
				string textolido;
				for (string line; getline(imput, line);)
					TempVECTOR.push_back(stoi(line));
				return TempVECTOR;
			}
		}

		namespace Float
		{
			std::vector<float> GetValues()
			{
				std::vector<float> TempVECTOR;
				ifstream imput(TXTFilePath);
				string textolido;
				for (string line; getline(imput, line);)
					TempVECTOR.push_back(stof(line));
				return TempVECTOR;
			}
		}


	};
	namespace INIFile
	{
		std::string INIFilePath;//Exemplo no mesmo diretorio do EXE:   .\\ArquivoINI.ini

		namespace String
		{
			void GravarString(std::string string, std::string app, std::string key)
			{
				WritePrivateProfileStringA(app.c_str(), key.c_str(), string.c_str(), INIFilePath.c_str());
			}

			std::string LerString(std::string app, std::string key)
			{
				char buf[100];
				GetPrivateProfileStringA(app.c_str(), key.c_str(), "NULL", buf, 100, INIFilePath.c_str());
				return (std::string)buf;
			}
		}
		namespace Int
		{
			void GravarInt(int value, std::string app, std::string key)
			{
				String::GravarString(std::to_string(value), app, key);
			}
			int LerInt(std::string app, std::string key)
			{
				return std::stoi(String::LerString(app, key));
			}
		}

		namespace Float
		{
			void GravarFloat(float value, std::string app, std::string key)
			{
				String::GravarString(std::to_string(value), app, key);
			}
			float LerFloat(std::string app, std::string key)
			{
				return std::stof(String::LerString(app, key));
			}
		}
	}
};
